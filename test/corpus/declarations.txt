================================================================================
Function declarations
================================================================================

fn main() {}

fn add(x: int, y: int): int {
    return x + y;
}

fn takes_slice(slice: string) {
}

fn foo(): string {
    return "hello;
}

fn foo<T>(x: T?): string? {}

--------------------------------------------------------------------------------

(source_file
  (function_item
    name: (identifier)
    parameters: (parameters)
    body: (block))
  (function_item
    name: (identifier)
    parameters: (parameters
      (parameter
        pattern: (identifier)
        type: (primitive_type))
      (parameter
        pattern: (identifier)
        type: (primitive_type)))
    return_type: (primitive_type)
    body: (block
      (expression_statement
        (return_expression
          (binary_expression
            left: (identifier)
            right: (identifier))))))
  (function_item
    name: (identifier)
    parameters: (parameters
      (parameter
        pattern: (identifier)
        type: (primitive_type)))
    body: (block))
  (function_item
    name: (identifier)
    parameters: (parameters)
    return_type: (primitive_type)
    body: (block
      (return_expression
        (string_literal
          (string_fragment)
          (MISSING """)))))
  (function_item
    name: (identifier)
    type_parameters: (type_parameters
      (type_identifier))
    parameters: (parameters
      (parameter
        pattern: (identifier)
        type: (type_identifier)))
    return_type: (primitive_type)
    body: (block)))

================================================================================
Variable declarations
================================================================================

let x: int = 5;
const API_HOST: string = "https://api.example.com";
let a = [string] { "Foo", "Bar" };
let b = <string, int> { "Foo": 1, "Bar": 2 };

--------------------------------------------------------------------------------

(source_file
    (let_declaration
    (identifier)
    (primitive_type)
    (integer_literal))
    (const_item
    (identifier)
    (primitive_type)
    (string_literal
        (string_fragment)))
    (let_declaration
    (identifier)
    (array_expression
        (array_type
        (primitive_type))
        (string_literal
        (string_fragment))
        (string_literal
        (string_fragment))))
    (let_declaration
    (identifier)
    (map_expression
        (map_type
        (primitive_type)
        (primitive_type))
        (string_literal
        (string_fragment))
        (integer_literal)
        (string_literal
        (string_fragment))
        (integer_literal))))

================================================================================
Use
================================================================================

use std.json;
use std.net.http.{self, Headers, Request};

--------------------------------------------------------------------------------

(source_file
  (use_declaration
    (scoped_identifier
      (identifier)
      (identifier)))
  (use_declaration
    (scoped_use_list
      (scoped_identifier
        (scoped_identifier
          (identifier)
          (identifier))
        (identifier))
      (use_list
        (self)
        (identifier)
        (identifier)))))

================================================================================
Struct
================================================================================

struct User {
    name: string,
    email: string?,
}

--------------------------------------------------------------------------------

(source_file
  (struct_item
    (type_identifier)
    (field_declaration_list
      (field_declaration
        (field_identifier)
        (primitive_type))
      (field_declaration
        (field_identifier)
        (primitive_type)))))

================================================================================
Switch statement
================================================================================
let a = "foo";
switch (x) {
    case 1:
        let a = "one";
    case 2: {
        let a = "two";
    }
    default:
        let a = "default";
}

--------------------------------------------------------------------------------

(source_file
  (let_declaration
    (identifier)
    (string_literal
      (string_fragment)))
  (expression_statement
    (switch_expression
      (parenthesized_expression
        (identifier))
      (switch_block
        (switch_case_arm
          (integer_literal)
          (expression_statement
            (assignment_expression
              (identifier)
              (ERROR
                (identifier))
              (string_literal
                (string_fragment)))))
        (switch_case_arm
          (integer_literal)
          (expression_statement
            (block
              (let_declaration
                (identifier)
                (string_literal
                  (string_fragment))))))
        (switch_case_arm
          (expression_statement
            (assignment_expression
              (identifier)
              (ERROR
                (identifier))
              (string_literal
                (string_fragment)))))))))

================================================================================
String interpolation
================================================================================

let name = "Alice";
let greeting = `Hello,\n ${name}!`;
let c = `foo`;

--------------------------------------------------------------------------------

(source_file
  (let_declaration
    (identifier)
    (string_literal
      (string_fragment)))
  (let_declaration
    (identifier)
    (string_template
      (string_fragment)
      (escape_sequence)
      (string_fragment)
      (string_template_substitution
        (identifier))
      (string_fragment)))
  (let_declaration
    (identifier)
    (string_template
      (string_fragment))))

================================================================================
Test & Bench
================================================================================

test "hello" {
    assert_eq 1, 1;
}

bench "hello" {
    assert_eq 1, 1;
}

--------------------------------------------------------------------------------

(source_file
    (test_item
    (string_literal
        (string_fragment))
    (block
        (expression_statement
        (identifier)
        (ERROR
            (integer_literal)
            (integer_literal)))))
    (test_item
    (string_literal
        (string_fragment))
    (block
        (expression_statement
        (identifier)
        (ERROR
            (integer_literal)
            (integer_literal))))))

================================================================================
Try & Throw statement
================================================================================

try item.method();
try! item.method();

throw "error";

--------------------------------------------------------------------------------

(source_file
    (expression_statement
    (try_expression
        (call_expression
        (field_expression
            (identifier)
            (field_identifier))
        (arguments))))
    (expression_statement
    (try_expression
        (call_expression
        (field_expression
            (identifier)
            (field_identifier))
        (arguments))))
    (throw_item
    (expression_statement
        (string_literal
        (string_fragment)))))

================================================================================
Union type
================================================================================

pub type BindValue = int | string | bool | float | DateTime | Duration | [string] | [int] | [float];

--------------------------------------------------------------------------------

(source_file
    (type_item
    (visibility_modifier)
    (type_identifier)
    (union_type
        (primitive_type)
        (union_type
        (primitive_type)
        (union_type
            (primitive_type)
            (union_type
            (primitive_type)
            (union_type
                (type_identifier)
                (union_type
                (type_identifier)
                (union_type
                    (array_type
                    (primitive_type))
                    (union_type
                    (array_type
                        (primitive_type))
                    (union_type
                        (array_type
                        (primitive_type)))))))))))))

================================================================================
If let & For let
================================================================================

if (let a = value) {
}

for (let a in values) {
}

for (let key, value in values) {
}

--------------------------------------------------------------------------------

(source_file
    (expression_statement
    (if_expression
        (let_condition
        (identifier)
        (identifier))
        (block)))
    (expression_statement
    (for_expression
        (identifier)
        (identifier)
        (block)))
    (expression_statement
    (for_expression
        (identifier)
        (identifier)
        (identifier)
        (block))))

================================================================================
Type Assertion
================================================================================

let b = a.(string);

if (let b = value.(type)) {
}

--------------------------------------------------------------------------------

(source_file
    (let_declaration
    (identifier)
    (field_expression
        (identifier)
        (type_assertion
        (primitive_type))))
    (expression_statement
    (if_expression
        (let_condition
        (identifier)
        (field_expression
            (identifier)
            (type_assertion)))
        (block))))

================================================================================
Function Declaration with Map, Option
================================================================================

pub fn option_params(a: string, b: int?, c: int = 100, d: ..int?): <string, int?> throws {
}

fn test(named_values: <string, int?>): <string, int?> {
}

--------------------------------------------------------------------------------

(source_file
    (function_item
    (visibility_modifier)
    (identifier)
    (parameters
        (parameter
        (identifier)
        (primitive_type))
        (parameter
        (identifier)
        (primitive_type))
        (parameter
        (identifier)
        (primitive_type)
        (integer_literal))
        (parameter
        (identifier)
        (primitive_type)))
    (map_type
        (primitive_type)
        (primitive_type))
    (block))
    (function_item
    (identifier)
    (parameters
        (parameter
        (identifier)
        (map_type
            (primitive_type)
            (primitive_type))))
    (map_type
        (primitive_type)
        (primitive_type))
    (block)))

================================================================================
Closure Expression
================================================================================

let a = |x: int, y: int| {
    return x + y;
};

call(|x, y| {
    return x + y;
});

--------------------------------------------------------------------------------

(source_file
    (let_declaration
    (identifier)
    (closure_expression
        (closure_parameters
        (parameter
            (identifier)
            (primitive_type))
        (parameter
            (identifier)
            (primitive_type)))
        (block
        (expression_statement
            (return_expression
            (binary_expression
                (identifier)
                (identifier)))))))
    (expression_statement
    (call_expression
        (identifier)
        (arguments
        (closure_expression
            (closure_parameters
            (identifier)
            (identifier))
            (block
            (expression_statement
                (return_expression
                (binary_expression
                    (identifier)
                    (identifier))))))))))
